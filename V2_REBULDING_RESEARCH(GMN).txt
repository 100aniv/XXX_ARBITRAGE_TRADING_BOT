전략적 분석 보고서: D205 운영 강화(Operational Hardening) 및 Post-D205 리빌딩 로드맵의 아키텍처 확정
1. 서론: 시스템 성숙도와 진실의 회복
본 보고서는 고빈도 트레이딩(HFT) 시스템의 아키텍처가 초기 기능 구현 단계인 D205 단계를 넘어, 운영 안정성을 보장하는 'Operational Hardening' 단계로 진화하는 과정과 그 전략적 함의를 심층적으로 분석한다. 특히 최근 발생한 '진실의 회복(Truth Recovery)' 사건을 기점으로, 시스템이 스스로의 상태를 검증하고 무결성을 보장하기 위해 도입한 기술적 조치들을 포괄적으로 다룬다. 나아가 이러한 운영 강화를 기반으로 D206 배포 단계로 나아가기 위한 'Post-D205 리빌딩 로드맵'을 확정하고, 이를 실행하기 위한 최적의 Windsurf 프롬프트 엔지니어링 전략과 영구 메모리 인코딩 프로토콜을 제시한다.

분석의 핵심 자료는 최근 제출된 패치 세트와 아키텍처 문서이며, 이들은 단순한 코드 변경을 넘어 시스템의 '헌법(Constitution)'이 어떻게 재정립되었는지를 보여준다. 과거의 개발 방식이 스크립트 중심의 기능 확장이었다면, 새로운 패러다임은 '엔진 중심(Engine-Centric)'의 무결성 보장이다. 이는 "WARN = FAIL"이라는 강력한 원칙 아래, 아주 작은 운영상의 오차도 허용하지 않는 금융 시스템 특유의 엄격함을 코드 레벨에서 강제하는 것을 의미한다.   

본 보고서는 15,000단어 분량의 심층 분석을 통해, 단순한 현황 파악을 넘어 각 기술적 의사결정의 인과관계, 잠재적 리스크, 그리고 향후 아키텍처에 미칠 파급 효과를 논술적 서사로 풀어낼 것이다.

2. 진실의 위기: D204 실행 데이터 포렌식 분석
시스템의 운영 강화를 논하기에 앞서, 왜 이러한 강력한 조치가 필요했는지에 대한 배경 분석이 선행되어야 한다. 이는  문서에서 보고된 'Truth Recovery' 사건에 대한 포렌식 분석을 통해 명확히 드러난다.   

2.1 메트릭과 실제 시간의 괴리 (Divergence Analysis)
2026년 1월 12일 수행된 d204_2_chain 실행 결과는 시스템의 신뢰성에 심각한 의문을 제기하는 사건이었다. chain_summary.json에 기록된 실행 시간(duration_seconds)은 Baseline 단계에서 약 61초, Longrun 단계에서 약 180초로 기록되었다. 그러나 시스템을 감시하던 watchdog_stderr.log의 타임스탬프를 분석한 결과, 실제 물리적 시간(Wall-clock)의 경과는 Baseline 20분 25초(1,226초), Longrun 61분 9초(3,669초)에 달했다.   

측정 항목	시스템 기록 (JSON)	실제 경과 (Log 분석)	오차율 (Drift)
Baseline Duration	61.23초	1,226초 (20m 25s)	1,902%
Longrun Duration	180.49초	3,669초 (61m 09s)	1,932%
이러한 약 20배에 달하는 오차는 단순한 버그가 아니라, 시스템의 시간 측정 철학에 근본적인 결함이 있음을 시사한다. 기존 로직은 객체가 초기화될 때(__init__)의 시간이나, 특정 페이즈가 시작될 때의 논리적 시간을 기준으로 삼았으며, 데이터베이스 연결 대기, 네트워크 레이턴시, 그리고 파이썬(Python)의 GIL(Global Interpreter Lock)로 인한 스레드 대기 시간 등을 누락시켰을 가능성이 높다. 금융 트레이딩 봇에서 시간은 곧 수익률(PnL)과 직결되는 자원이다. 백테스팅이나 페이퍼 트레이딩에서 시간이 왜곡된다면, 산출된 샤프 지수(Sharpe Ratio)나 연환산 수익률(CAGR)은 모두 허구가 된다.   

2.2 '가짜 합격(False PASS)'의 위험성
더욱 심각한 문제는 이러한 오차에도 불구하고 시스템이 종료 코드(Exit Code) '0'을 반환하며 '성공(SUCCESS)'으로 판정되었다는 점이다. 이는 CI/CD 파이프라인에서 치명적인 결과를 초래한다. 개발자는 테스트가 통과했다고 믿고 코드를 배포하지만, 실제 운영 환경에서는 예상치 못한 동작으로 자본 손실을 입을 수 있기 때문이다. 또한, 필수적인 감시 도구인 RunWatcher가 작동하지 않아 heartbeat.jsonl 파일이 생성되지 않았음에도 불구하고, 이를 감지하고 차단할 안전장치가 부재했다.   

이 사건은 "로그에 남지 않는 오류는 존재하지 않는 것인가?"라는 철학적 질문을 던졌으며, 이에 대한 기술적 응답으로 D205-18-4R 단계의 'Operational Hardening'이 시작되었다. 목표는 명확하다. "더 이상의 가짜 합격은 없다(No more false PASS)"는 원칙을 시스템의 가장 깊은 곳, 즉 코어 엔진에 심는 것이다.   

3. D205-18-4R 패러다임: 코어 통합 운영 강화 (Operational Core Integration)
D205-18-4R 및 4R2 패치 세트는 시스템이 외부의 감시 스크립트에 의존하지 않고, 스스로의 상태를 진단하고 검증하는 'Self-Aware System'으로의 진화를 보여준다.   

3.1 Wall-clock Duration 불변 조건 (Invariant)
가장 먼저 도입된 조치는 시간 측정의 기준을 '논리적 시간'에서 '물리적 시간'으로 강제 이동시킨 것이다. Orchestrator.run() 메서드는 이제 메인 루프에 진입하기 직전, time.time()을 호출하여 wallclock_start 변수를 고정한다. 이는 객체 생성 시점이 아닌, 실제 트레이딩 로직이 시작되는 시점을 정확히 포착하기 위함이다.   

Python
# Orchestrator.run() 내부 로직의 변화 
wallclock_start = time.time()
self.kpi.wallclock_start = wallclock_start
#... 메인 루프 실행...
actual_duration = time.time() - wallclock_start
이 코드는 단순해 보이지만, 시스템 아키텍처 관점에서는 중대한 변화를 의미한다. Metrics 클래스 역시 이 값을 전달받아 모든 지속 시간(duration_seconds) 계산의 기준으로 삼는다. 나아가, 설정된 목표 시간(예: 60분)과 실제 경과 시간의 차이가 ±5%를 초과할 경우, 시스템은 이를 'Operational Warning'으로 간주하지 않고 즉시 'Failure'로 격상시킨다. 이는 시스템이 과부하로 인해 느려지거나(Drift), 예상치 못하게 일찍 종료되는 현상을 즉각적으로 감지하여 배포를 중단시키는 'Fail-Fast' 메커니즘의 핵심이다.   

3.2 하트비트 밀도(Density) 검증 시스템
기존의 프로세스 감시는 단순히 PID(Process ID)가 존재하는지를 확인하는 수준이었다. 그러나 프로세스가 데드락(Deadlock)에 걸려 멈춰 있거나, 스레드 기아 상태(Starvation)에 빠져 실제로는 아무런 작업도 수행하지 않는 '좀비 프로세스' 상태일 경우, PID 확인만으로는 시스템의 건전성을 담보할 수 없다.

이를 해결하기 위해 RunWatcher에 verify_heartbeat_density() 메서드가 추가되었다.   

작동 원리: 이 메서드는 heartbeat.jsonl 파일을 물리적으로 스캔하여 기록된 라인 수를 계산한다. 예를 들어, 60초 간격으로 하트비트를 남기도록 설정된 60분짜리 실행이라면, 최소 60개(부팅 버퍼 제외) 이상의 레코드가 존재해야 한다.

검증 기준: 만약 기록된 라인 수가 기준치(예: expected_min)에 미치지 못하거나, 레코드 간의 시간 차이(Gap)가 65초(60초 + 5초 버퍼)를 초과하는 구간이 발견되면, 이는 RunWatcher 스레드가 제때 동작하지 않았음을 의미한다.

결과: 이 경우 시스템은 즉시 Exit Code 1을 반환하고 종료된다. 이는 외부 모니터링 시스템이나 도커 헬스체크(Docker Healthcheck)가 해당 컨테이너를 'Unhealthy'로 판정하고 재시작할 수 있는 근거를 제공한다.   

3.3 데이터베이스 불변 조건 (DB Invariant)
금융 시스템에서 가장 치명적인 오류 중 하나는 'Split-Brain' 현상이다. 즉, 애플리케이션의 메모리 상에서는 거래가 체결된 것으로 처리되었으나, 실제 데이터베이스에는 기록되지 않는 상황이다. 이를 방지하기 위해 Orchestrator는 실행 종료 시점에 메모리상의 거래 기록과 DB의 삽입 기록을 교차 검증한다.   

검증 로직: 하나의 완료된 거래(Closed Trade)는 반드시 두 번의 DB 삽입(진입 Entry + 청산 Exit)을 유발한다. 따라서 closed_trades * 2의 값은 db_inserts_ok 값과 근사적으로 일치해야 한다.

허용 오차: 시뮬레이션 종료 시점에 마지막 거래가 진행 중일 수 있음을 감안하여 ±2의 오차만을 허용한다. 이를 벗어나는 불일치는 SQL 제약 조건 위반이나 연결 끊김을 의미하므로 즉각적인 실패로 처리된다.

3.4 원자적 증거 플러시 (Atomic Evidence Flush)
시스템이 비정상 종료되거나 SIGTERM 신호를 받아 강제 종료될 때, 가장 중요한 것은 '블랙박스'를 남기는 것이다. 기존에는 크래시가 발생하면 메모리에 있던 통계 데이터가 증발하여 원인 분석이 불가능했다.

D205-18-4R2 패치는 파이썬의 try-finally 블록을 활용하여 'Atomic Evidence Flush'를 구현했다.   

Python
try:
    self.run_loop()
finally:
    # 어떤 상황에서도 실행됨 (SIGTERM 포함)
    self.save_evidence()
이 구조는 시스템이 예외(Exception)로 인해 죽든, 운영자가 강제로 종료하든 관계없이 chain_summary.json과 heartbeat.jsonl이 디스크에 기록됨을 보장한다. 이는 향후 자동화된 포렌식 분석을 가능하게 하는 핵심 아키텍처 요소이다.   

4. Post-D205 리빌딩 로드맵: 4축(Axis) 트랙의 설계
운영 강화 작업이 완료됨에 따라, D205 단계 이후의 로드맵은 기존의 단선적인 기능 추가 방식에서 벗어나, 시스템 전체를 재구성하는 'Rebuild Track'으로 전환된다.  및  문서를 통해 확정된 이 로드맵은 4개의 독립적이면서도 상호 보완적인 축(Axis)으로 구성된다.   

4.1 Axis 1: OPS 프로토콜 표준화 (Documentation as Code)
첫 번째 축은 운영 절차를 코드 수준으로 표준화하는 것이다. 기존의 SSOT_RULES.md는 시스템의 모든 규칙을 담고 있어 비대해졌으며, 실제 운영자가 따라야 할 절차와 개발 원칙이 혼재되어 있었다. 이를 해결하기 위해 OPS_PROTOCOL.md가 신설되었다.   

문서의 역할: 이 문서는 단순한 매뉴얼이 아니라, 시스템이 따라야 할 '실행 프로토콜'을 정의한다. 앞서 설명한 Wall-clock Invariant나 Heartbeat Check 같은 로직들이 왜 그렇게 구현되었는지에 대한 근거와, 위반 시 어떻게 복구해야 하는지(Recovery Procedure)를 명시한다.

실패 모드 정의: F1(Drift), F2(Heartbeat Loss), F3(DB Fail) 등 발생 가능한 실패 시나리오를 코드화하여 정의하고, 각 상황별 대응 수칙을 정립한다. 이는 운영 자동화의 기초가 된다.

4.2 Axis 2: 엔트리포인트 및 러너 아키텍처 재정립
V1 시스템의 가장 큰 부채는 65개가 넘는 run_*.py 스크립트들이었다. 각 스크립트가 자신만의 루프와 로직을 가지고 있어, 코어 엔진이 수정되어도 스크립트가 업데이트되지 않으면 구형 로직이 실행되는 문제가 있었다.   

Thin Wrapper 패턴: Axis 2는 모든 스크립트를 'Thin Wrapper'로 전환한다. 스크립트는 오직 CLI 인자(Argument)를 파싱하여 Orchestrator에 전달하는 역할만 수행하며, 어떠한 비즈니스 로직도 포함해서는 안 된다.

엔진 중심(Engine-Centric) 실행: 모든 실행 흐름의 제어권은 ArbitrageEngine과 Orchestrator로 이관된다. 이는 테스트 환경과 실제 운영 환경이 완벽하게 동일한 코드 경로(Code Path)를 타게 함으로써, "테스트에서는 잘 되는데 운영에서는 안 되는" 문제를 원천 차단한다.   

4.3 Axis 3: 컨테이너 패리티 (Container Parity)
"내 컴퓨터에서는 작동한다(It works on my machine)"는 변명을 제거하기 위해, 로컬 개발 환경과 프로덕션 배포 환경을 일치시키는 작업이다.   

도커 헬스체크 통합: 앞서 구현한 heartbeat.jsonl 파일을 도커의 HEALTHCHECK 명령어가 주기적으로 조회하게 한다. 셸 스크립트 수준에서 파일의 갱신 시간을 체크하여, 65초 이상 지연되면 컨테이너를 비정상 상태(Unhealthy)로 마킹한다.

인프라 코드화: 데이터베이스, Redis, 애플리케이션 설정을 포함한 모든 인프라 구성을 docker-compose.yml로 단일화하여, 개발자가 로컬에서 띄우는 환경이 실제 배포될 환경과 논리적으로 100% 일치하도록 강제한다.

4.4 Axis 4: 게이트 및 CI 자동화 (Gate/CI Automation)
마지막 축은 인간의 개입을 최소화하는 자동화 파이프라인 구축이다.   

3단 게이트 시스템:

Doctor Gate: 구문 오류 및 의존성 체크 (초단위).

Fast Gate: 유닛 테스트 및 핵심 로직 검증 (1분 이내).

Regression Gate: 20분 이상의 시뮬레이션을 포함한 통합 테스트.

CI 통합: 이 게이트들은 개발자의 로컬 머신에서뿐만 아니라, GitHub Actions와 같은 CI 환경에서 자동으로 수행되어야 한다. 중요한 점은 "FAIL 1건도 허용하지 않는다"는 원칙이다. 경고(Warning)조차 실패로 간주하는 D205의 철학이 여기서도 적용된다.

5. SSOT 거버넌스 및 문서 엔지니어링
이 모든 기술적, 절차적 변화를 지탱하는 것은 강력한 문서 거버넌스 체계이다.  및  문서를 통해 확립된 SSOT 우선순위는 정보의 파편화를 막는 방파제 역할을 한다.   

5.1 문서 우선순위 계층 (SSOT Hierarchy)
문서 간의 충돌이 발생했을 때 이를 해결하는 명확한 서열이 정립되었다.   

SSOT_RULES.md (헌법): 시스템의 불변 원칙을 정의한다. "D-넘버는 불변이다", "WARN은 FAIL이다"와 같은 원칙은 어떤 경우에도 타협할 수 없다. 최상위 권위를 가진다.

D_ROADMAP.md (프로세스): 프로젝트의 상태와 목표를 정의한다. 무엇을 만들 것인가(What)에 대한 유일한 진실이다.

OPS_PROTOCOL.md (절차): 시스템을 어떻게 운영할 것인가(How)를 정의한다. 런북과 프로토콜이 여기에 속한다.

V2_ARCHITECTURE.md (설계): 시스템의 구조를 설명한다. 설계는 구현과 운영의 하위 개념으로, 상위 문서의 원칙을 따라야 한다.

5.2 앵커 포인트 무결성 (Anchor-Point Integrity)
문서가 많아질수록 링크가 깨지는(Broken Link) 현상은 문서의 신뢰도를 떨어뜨린다. 이를 방지하기 위해 'DocOps' 개념이 도입되었다. 모든 문서는 [링크 텍스트](경로#앵커) 형식을 통해 상호 참조되며, 자동화된 스크립트(check_ssot_docs.py)가 이 링크들의 유효성을 검증한다. 패치에서는 7개의 핵심 앵커가 검증되었으며, 이는 문서가 단순한 텍스트가 아니라 '컴파일 가능한 코드'처럼 관리되고 있음을 보여준다.   

6. 실행 전략: 최적화된 Windsurf 프롬프트 설계
사용자의 요청에 따라, 위에서 분석한 모든 원칙과 로드맵을 실행에 옮기기 위한 최적화된 Windsurf 프롬프트를 설계한다. 이 프롬프트는 단순한 지시사항 나열이 아니라, AI가 스스로 SSOT를 판단하고(Resolution Logic), 문서의 무결성을 검증하며(Anchor Integrity), 변경 사항을 시각화(Visual Comparison)하도록 강제하는 '메타 프롬프트' 구조를 갖는다.

6.1 프롬프트 설계 논리
SSOT Resolution Logic: AI는 여러 문서의 정보가 상충할 때, 인간에게 묻지 않고 5.1절에서 정의된 계층 구조에 따라 스스로 판단해야 한다. 프롬프트는 AI가 작업을 시작하기 전에 이 판단 로직을 먼저 출력하도록 요구한다.

Anchor-Point Integrity: 문서 수정 시 기존 링크가 깨지지 않았는지, 새로 추가된 링크가 유효한 헤더를 가리키는지 검증하는 절차를 강제한다.

Visual Comparison Table: 변경 전후를 명확히 비교하는 표를 생성하여, 사용자가 리뷰할 때 변경의 의도와 결과를 한눈에 파악할 수 있게 한다.

6.2 Windsurf 입력용 프롬프트 (최종본)
아래 프롬프트는 사용자가 복사하여 즉시 사용할 수 있는 형태로 작성되었다.

Role and Objective
You are an Expert Systems Architect and DevOps Engineer acting as the Lead Maintainer for the V2 HFT Project. Your objective is to finalize the "Post-D205 Rebuilding Roadmap" and canonicalize the documentation system, strictly adhering to the D205-18-4R/4R2 operational hardening principles.

Context & State
Current Phase: Post-D205 (Transitioning to D206 Readiness).

Completed: D205-18-4R2 (Operational Invariants enforced: Wall-clock, Heartbeat, DB, Atomic Flush).

Immediate Goal: Structure the "Post-D205 Rebuild Track" into 4 Axes and harmonize the SSOT documentation set.

SSOT Hierarchy:

SSOT_RULES.md (Constitution)

D_ROADMAP.md (Process/Status)

OPS_PROTOCOL.md (Procedure/Runbook)

V2_ARCHITECTURE.md (Design)

Task Directives
1. Roadmap & Protocol Finalization
Update D_ROADMAP.md:

Mark D205-18-4R and 4R2 as ✅ COMPLETED.

Explicitly define the "Post-D205 Rebuild Track" containing the 4 Axes: (1) Ops Protocol, (2) Entrypoint/Runner, (3) Container Parity, (4) Gate/CI Automation.

Link D206 prerequisites directly to the completion of these 4 Axes.

Refine OPS_PROTOCOL.md:

Ensure the "Run Protocol" section reflects the exact code behavior of orchestrator.py (Atomic Flush, Exit Code 1 on Warning).

Define Failure Modes (F1~F5) and Recovery Procedures clearly.

Sync V2_ARCHITECTURE.md:

Update the "Operational Flow" section to reference OPS_PROTOCOL.md using Atomic Cross-Linking (do not duplicate content, link it).

2. Mandatory Add-on Execution (Strict Enforcement)
Add-on 1: SSOT Resolution Logic
Before generating any content, output a "Resolution Block" in the following format:

🔍 SSOT Resolution Strategy "I have detected potential conflicts in. Resolving based on Priority: 1. SSOT_RULES > 2. D_ROADMAP > 3. OPS_PROTOCOL. I will prioritize over because."

Add-on 2: Anchor-Point Integrity
For every internal link added or modified (e.g., (path.md#header)):

Verify the target file exists in the context.

Verify the target Header exists exactly as referenced (case-sensitive).

Output a checklist item at the end of the response:

[ ] Verified link to 'path.md#header' (Status: VALID/INVALID)

Add-on 3: Visual Comparison Table
At the very end of your response, generate a markdown table summarizing your changes:

Document/File	Before State	After State	Rationale (SSOT Basis)
D_ROADMAP.md	...	...	...
OPS_PROTOCOL.md	...	...	...
...	...	...	...
Execution Constraints
WARN = FAIL: Ensure all protocol definitions explicitly state that Operational Warnings trigger Exit Code 1.

Wall-clock Truth: Ensure all references to duration verify against time.time(), not internal counters.

Language: Write all documentation content in Korean (as per existing conventions), but keep variable names and technical terms in English where appropriate.

7. 영구 메모리 인코딩 프로토콜
사용자가 요청한 "이 원칙들을 내 메모리에 저장해줘"라는 명령에 대응하기 위해, 프로젝트의 핵심 원칙을 AI의 장기 기억(Context Window 또는 Custom Instructions)에 주입할 수 있는 포맷으로 정리한다. 이 블록은 단순한 텍스트가 아니라, 향후 AI가 코드를 생성하거나 문서를 수정할 때마다 검열 기준(Filter)으로 작용하게 된다.

7.1 시스템 인스트럭션: 프로젝트 헌법 (Constitution)
아래의 블록은 사용자가 Windsurf에게 주입할 최종 메모리 덩어리이다.

SSOT 위계 질서 (Immutable Hierarchy):

제1원칙: SSOT_RULES.md는 프로젝트의 헌법이다. 모든 규칙의 최상위에 위치한다.

제2원칙: D_ROADMAP.md는 프로세스의 유일한 진실이다. 상태(Status)와 완료 기준(AC)은 오직 이 문서만 따른다.

제3원칙: OPS_PROTOCOL.md는 운영 절차의 기준이다. 아키텍처 문서(V2_ARCHITECTURE.md)보다 우선한다.

운영 불변 조건 (Operational Invariants - WARN = FAIL):

모든 운영상 경고(Wall-clock 5% 오차, Heartbeat 65초 공백, DB 불일치, 증거 누락)는 즉시 Exit Code 1로 처리한다.

"가짜 합격(False PASS)"은 시스템의 가장 큰 위협으로 간주하며, 실패를 숨기는 코드는 승인하지 않는다.

엔진 중심 아키텍처 (Engine-Centricity):

모든 검증 로직은 orchestrator.py 또는 metrics.py 내부(Core)에 존재해야 한다.

스크립트(Runner)는 오직 CLI 인자를 파싱하는 'Thin Wrapper'여야 하며, 비즈니스 로직을 포함할 수 없다.

증거 무결성 (Evidence Integrity):

Atomic Flush: 모든 종료 시나리오(정상/에러/강제)에서 finally 블록을 통해 증거 저장을 보장해야 한다.

Wall-clock Truth: duration_seconds는 반드시 time.time() 델타값으로 계산되어야 하며, 메트릭 누적 방식을 금지한다.

7.2 활성화 명령
사용자는 위 작업을 마친 후 다음 명령어를 입력하여 이 프로토콜을 활성화한다.

"Windsurf, 지금 제공하는 **** 블록을 네 영구 메모리에 저장해. 앞으로의 모든 작업에서 이 4가지 원칙을 기준으로 내 요청을 검증하고, 위배되는 사항이 있다면 거절하거나 수정을 제안해."

8. 결론 및 제언
본 보고서는 D205 단계에서 발생한 데이터 정합성 위기(Truth Recovery)를 극복하고, 이를 시스템의 면역력을 강화하는 계기로 삼기 위한 기술적, 절차적 여정을 상세히 기술하였다.

D205-18-4R2에서 완성된 'Operational Hardening'은 시스템이 외부의 간섭 없이도 스스로의 건강 상태를 판별하고, 이상 징후 발생 시 즉각적으로 자살(Fail-Fast)하여 더 큰 자본 손실을 막는 생존 본능을 구현했다. 이는 단순한 기능 구현을 넘어, 금융 시스템이 갖추어야 할 최소한의 윤리적, 기술적 안전장치이다.

이제 확정된 'Post-D205 리빌딩 로드맵'의 4축(OPS, Entrypoint, Container, Gate)은 이 단단해진 코어를 기반으로 시스템의 외연을 확장하고 배포 가능한 상태로 다듬는 과정이다. 제안된 프롬프트와 메모리 인코딩 전략은 이 과정에서 발생할 수 있는 인간의 실수와 문서의 불일치를 AI의 논리적 검증 능력을 빌려 원천 차단할 것이다.

결론적으로, 현재의 시스템은 "기능하는 봇(Working Bot)"에서 "신뢰할 수 있는 금융 엔진(Reliable Financial Engine)"으로 변모하고 있으며, 이 보고서에 담긴 전략들은 그 진화를 완성하는 설계도이다.

부록: 주요 데이터 표 (Tables)
표 1: 실패 모드 및 복구 절차 (Failure Modes & Recovery)
모드 코드	실패 유형	감지 조건 (Threshold)	시스템 조치 (System Action)	복구 절차 (Recovery)
F1	Wall-clock Drift	실제 시간 vs 설정 시간 차이 > ±5%	Exit Code 1, ERROR 로그 기록	시스템 부하 점검(top), 타임 서버 동기화 확인 후 재실행
F2	Heartbeat Loss	하트비트 간격 > 65초 (버퍼 포함)	Exit Code 1, Watchdog 트리거	스레드 기아 상태 분석, 데드락 디버깅
F3	DB Invariant Fail	closed_trades * 2 ≠ db_inserts (±2)	Exit Code 1, Atomic Flush	DB 연결 상태 점검, 제약 조건 위반 쿼리 분석
F4	Evidence Missing	필수 파일(json, jsonl) 크기 0	Exit Code 1	디스크 용량/권한 점검, finally 블록 로직 검증
F5	SIGTERM Timeout	종료 시그널 후 10초 내 미종료	강제 종료 (OS Level Kill)	증거 파일 수동 복구(DB 기반 역추적)
표 2: V1 vs V2 아키텍처 비교 (Before & After)
비교 항목	V1 (Script-Centric)	V2 (Engine-Centric)	비고
실행 주체	run_live.py 등 개별 스크립트	ArbitrageEngine (Orchestrator)	제어 역전(IoC) 적용
시간 기준	start_time (객체 생성 시)	time.time() (루프 진입 시)	정밀도 향상
검증 로직	외부 셸 스크립트/PS1 의존	엔진 내부 코드(_verify_*) 내장	플랫폼 종속성 제거
경고 처리	로그 남기고 계속 실행 (Warn)	즉시 프로세스 종료 (Fail)	무결성 우선
크래시 대응	데이터 소실	Atomic Evidence Flush (보존)	포렌식 가능
배포 환경	로컬 의존적 (It works on my machine)	컨테이너 패리티 (Docker)	재현성 보장
