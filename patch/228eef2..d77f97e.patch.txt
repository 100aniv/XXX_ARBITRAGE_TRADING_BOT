From d77f97ee9f368ee87fbf3ab7079c4f09cde69990 Mon Sep 17 00:00:00 2001
From: 100aniv <bback_g@ciloud.com>
Date: Tue, 30 Dec 2025 01:41:08 +0900
Subject: [PATCH] [D203-3] OpportunityOrderIntent bridge + SSOT hygiene (Gate
 PASS)

---
 D_ROADMAP.md                                  |   8 +-
 arbitrage/v2/opportunity/intent_builder.py    | 213 +++++++++++
 docs/v2/reports/D203/D203-1_REPORT.md         |  59 +--
 docs/v2/reports/D203/D203-2_REPORT.md         | 154 ++++++++
 ...test_d203_3_opportunity_to_order_intent.py | 350 ++++++++++++++++++
 5 files changed, 734 insertions(+), 50 deletions(-)
 create mode 100644 arbitrage/v2/opportunity/intent_builder.py
 create mode 100644 docs/v2/reports/D203/D203-2_REPORT.md
 create mode 100644 tests/test_d203_3_opportunity_to_order_intent.py

diff --git a/D_ROADMAP.md b/D_ROADMAP.md
index 77411a6..70bb722 100644
--- a/D_ROADMAP.md
+++ b/D_ROADMAP.md
@@ -2612,7 +2612,7 @@ python -m pytest tests/test_d27_monitoring.py tests/test_d82_0_runner_executor_i
 
 #### D203-1: Break-even Threshold ê³µì‹ (SSOT)
 **ìƒíƒœ:** âœ… DONE  
-**ì»¤ë°‹:** [ì‘ì—… ì¤‘]  
+**ì»¤ë°‹:** `228eef2`  
 **í…ŒìŠ¤íŠ¸:** 9/9 PASS (0.24s)  
 **ë¬¸ì„œ:** `docs/v2/reports/D203/D203-1_REPORT.md`
 
@@ -2654,9 +2654,9 @@ threshold_bps = config.exchanges.upbit.taker_fee_bps + \
 
 #### D203-2: Opportunity Detector v1 (ì˜µì…˜ í™•ì¥)
 **ìƒíƒœ:** âœ… DONE  
-**ì»¤ë°‹:** [ì‘ì—… ì¤‘]  
+**ì»¤ë°‹:** `228eef2`  
 **í…ŒìŠ¤íŠ¸:** 6/6 PASS (0.18s)  
-**ë¬¸ì„œ:** `docs/v2/reports/D203/D203-1_REPORT.md` (D203-1ê³¼ í†µí•©)
+**ë¬¸ì„œ:** `docs/v2/reports/D203/D203-2_REPORT.md`
 
 **ëª©í‘œ:**
 - ë‘ ê±°ë˜ì†Œ ê°€ê²© ì…ë ¥ â†’ ê¸°íšŒ íƒì§€ âœ…
@@ -2675,7 +2675,7 @@ threshold_bps = config.exchanges.upbit.taker_fee_bps + \
 - âœ… BreakEvenParams ì¬ì‚¬ìš© (D203-1)
 - âœ… SpreadModel ë¡œì§ ì°¸ì¡° (V1: arbitrage/cross_exchange/spread_model.py)
 
-**Note:** ì›ë˜ D203-2ëŠ” "replay/backtest gate" ê³„íšì´ì—ˆìœ¼ë‚˜, D203-1ì˜ ìì—°ìŠ¤ëŸ¬ìš´ í™•ì¥ìœ¼ë¡œ Opportunity Detectorë¥¼ ë¨¼ì € êµ¬í˜„í•¨. Backtest gateëŠ” D204-2ë¡œ ì´ë™ ì˜ˆì •.
+**Note:** ì›ë˜ D203-2ëŠ” "replay/backtest gate" ê³„íšì´ì—ˆìœ¼ë‚˜, D203-1ì˜ ìì—°ìŠ¤ëŸ¬ìš´ í™•ì¥ìœ¼ë¡œ Opportunity Detectorë¥¼ ë¨¼ì € êµ¬í˜„í•¨. **Backtest gateëŠ” D204-2 (ê³„ë‹¨ì‹ Paper í…ŒìŠ¤íŠ¸)ë¡œ ì´ë™ ì™„ë£Œ.**
 
 **KPI í•„ìˆ˜ í•„ë“œ:**
 ```json
diff --git a/arbitrage/v2/opportunity/intent_builder.py b/arbitrage/v2/opportunity/intent_builder.py
new file mode 100644
index 0000000..c7f2a8a
--- /dev/null
+++ b/arbitrage/v2/opportunity/intent_builder.py
@@ -0,0 +1,213 @@
+"""
+D203-3: Opportunity â†’ OrderIntent Bridge
+
+ì–‡ì€ ì–´ëŒ‘í„°: OpportunityCandidateë¥¼ 2ê°œ OrderIntent(ë§¤ìˆ˜/ë§¤ë„)ë¡œ ë³€í™˜.
+
+Reuse-First:
+- OrderIntent (arbitrage/v2/core/order_intent.py)
+- OpportunityCandidate (arbitrage/v2/opportunity/detector.py)
+- BreakEvenParams (arbitrage/v2/domain/break_even.py)
+"""
+
+from typing import List, Optional
+
+from arbitrage.v2.core.order_intent import OrderIntent, OrderSide, OrderType
+from arbitrage.v2.opportunity.detector import (
+    OpportunityCandidate,
+    OpportunityDirection,
+    detect_candidates,
+)
+from arbitrage.v2.domain.break_even import BreakEvenParams
+
+
+def build_candidate(
+    symbol: str,
+    exchange_a: str,
+    exchange_b: str,
+    price_a: float,
+    price_b: float,
+    params: BreakEvenParams,
+) -> Optional[OpportunityCandidate]:
+    """
+    Build OpportunityCandidate from 2 exchange prices.
+    
+    Args:
+        symbol: Trading pair (e.g., "BTC/KRW")
+        exchange_a: Exchange A name (e.g., "upbit")
+        exchange_b: Exchange B name (e.g., "binance")
+        price_a: Exchange A price (normalized to same currency)
+        price_b: Exchange B price (normalized to same currency)
+        params: BreakEvenParams (fee_model, slippage_bps, buffer_bps)
+        
+    Returns:
+        OpportunityCandidate or None (if invalid price)
+        
+    Reuse:
+        - detect_candidates() from arbitrage/v2/opportunity/detector.py
+    """
+    return detect_candidates(
+        symbol=symbol,
+        exchange_a=exchange_a,
+        exchange_b=exchange_b,
+        price_a=price_a,
+        price_b=price_b,
+        params=params,
+    )
+
+
+def candidate_to_order_intents(
+    candidate: OpportunityCandidate,
+    base_qty: Optional[float] = None,
+    quote_amount: Optional[float] = None,
+    order_type: OrderType = OrderType.MARKET,
+    limit_price_a: Optional[float] = None,
+    limit_price_b: Optional[float] = None,
+) -> List[OrderIntent]:
+    """
+    Convert OpportunityCandidate to 2 OrderIntents (BUY + SELL).
+    
+    Policy (SSOT):
+        - unprofitable (edge_bps <= 0) â†’ ë¹ˆ ë¦¬ìŠ¤íŠ¸ (ì£¼ë¬¸ ìƒì„± ê¸ˆì§€)
+        - direction == NONE â†’ ë¹ˆ ë¦¬ìŠ¤íŠ¸
+        - direction == BUY_A_SELL_B â†’ [BUY(A), SELL(B)]
+        - direction == BUY_B_SELL_A â†’ [BUY(B), SELL(A)]
+    
+    Args:
+        candidate: OpportunityCandidate (from build_candidate or detect_candidates)
+        base_qty: Base asset quantity (for SELL orders)
+        quote_amount: Quote asset amount (for BUY orders)
+        order_type: MARKET or LIMIT (default: MARKET)
+        limit_price_a: Limit price for exchange A (if LIMIT)
+        limit_price_b: Limit price for exchange B (if LIMIT)
+        
+    Returns:
+        List of OrderIntent (empty if unprofitable or NONE direction)
+        
+    Logic:
+        1. Check profitable (edge_bps > 0)
+        2. Check direction != NONE
+        3. Create BUY intent (exchange with lower price)
+        4. Create SELL intent (exchange with higher price)
+        
+    Note:
+        - For MARKET orders: BUY requires quote_amount, SELL requires base_qty
+        - For LIMIT orders: both require limit_price
+    """
+    # Policy: unprofitable â†’ ë¹ˆ ë¦¬ìŠ¤íŠ¸
+    if not candidate.profitable:
+        return []
+    
+    # Policy: direction NONE â†’ ë¹ˆ ë¦¬ìŠ¤íŠ¸
+    if candidate.direction == OpportunityDirection.NONE:
+        return []
+    
+    intents = []
+    
+    if candidate.direction == OpportunityDirection.BUY_A_SELL_B:
+        # Aê°€ ì €ë ´ â†’ Aì—ì„œ ì‚¬ê³  Bì—ì„œ íŒ”ê¸°
+        buy_exchange = candidate.exchange_a
+        sell_exchange = candidate.exchange_b
+        buy_price = candidate.price_a
+        sell_price = candidate.price_b
+    else:
+        # direction == BUY_B_SELL_A
+        # Bê°€ ì €ë ´ â†’ Bì—ì„œ ì‚¬ê³  Aì—ì„œ íŒ”ê¸°
+        buy_exchange = candidate.exchange_b
+        sell_exchange = candidate.exchange_a
+        buy_price = candidate.price_b
+        sell_price = candidate.price_a
+    
+    # 1. BUY Intent
+    if order_type == OrderType.MARKET:
+        buy_intent = OrderIntent(
+            exchange=buy_exchange,
+            symbol=candidate.symbol,
+            side=OrderSide.BUY,
+            order_type=OrderType.MARKET,
+            quote_amount=quote_amount,
+        )
+    else:
+        # LIMIT
+        limit_price = limit_price_a if buy_exchange == candidate.exchange_a else limit_price_b
+        buy_intent = OrderIntent(
+            exchange=buy_exchange,
+            symbol=candidate.symbol,
+            side=OrderSide.BUY,
+            order_type=OrderType.LIMIT,
+            quote_amount=quote_amount,
+            limit_price=limit_price or buy_price,  # fallback to market price
+        )
+    
+    # 2. SELL Intent
+    if order_type == OrderType.MARKET:
+        sell_intent = OrderIntent(
+            exchange=sell_exchange,
+            symbol=candidate.symbol,
+            side=OrderSide.SELL,
+            order_type=OrderType.MARKET,
+            base_qty=base_qty,
+        )
+    else:
+        # LIMIT
+        limit_price = limit_price_b if sell_exchange == candidate.exchange_b else limit_price_a
+        sell_intent = OrderIntent(
+            exchange=sell_exchange,
+            symbol=candidate.symbol,
+            side=OrderSide.SELL,
+            order_type=OrderType.LIMIT,
+            base_qty=base_qty,
+            limit_price=limit_price or sell_price,  # fallback to market price
+        )
+    
+    intents.append(buy_intent)
+    intents.append(sell_intent)
+    
+    return intents
+
+
+def build_and_convert(
+    symbol: str,
+    exchange_a: str,
+    exchange_b: str,
+    price_a: float,
+    price_b: float,
+    params: BreakEvenParams,
+    base_qty: Optional[float] = None,
+    quote_amount: Optional[float] = None,
+    order_type: OrderType = OrderType.MARKET,
+) -> List[OrderIntent]:
+    """
+    Convenience function: build_candidate() + candidate_to_order_intents().
+    
+    Args:
+        symbol: Trading pair
+        exchange_a: Exchange A name
+        exchange_b: Exchange B name
+        price_a: Exchange A price
+        price_b: Exchange B price
+        params: BreakEvenParams
+        base_qty: Base asset quantity (for SELL)
+        quote_amount: Quote asset amount (for BUY)
+        order_type: MARKET or LIMIT
+        
+    Returns:
+        List of OrderIntent (empty if invalid/unprofitable)
+    """
+    candidate = build_candidate(
+        symbol=symbol,
+        exchange_a=exchange_a,
+        exchange_b=exchange_b,
+        price_a=price_a,
+        price_b=price_b,
+        params=params,
+    )
+    
+    if not candidate:
+        return []
+    
+    return candidate_to_order_intents(
+        candidate=candidate,
+        base_qty=base_qty,
+        quote_amount=quote_amount,
+        order_type=order_type,
+    )
diff --git a/docs/v2/reports/D203/D203-1_REPORT.md b/docs/v2/reports/D203/D203-1_REPORT.md
index b92be08..af6df70 100644
--- a/docs/v2/reports/D203/D203-1_REPORT.md
+++ b/docs/v2/reports/D203/D203-1_REPORT.md
@@ -1,8 +1,8 @@
-# D203-1 (+D203-2) Report
+# D203-1 Report: Break-even Threshold (SSOT)
 
 **ì‘ì„±ì¼:** 2025-12-30  
 **ìƒíƒœ:** âœ… DONE  
-**ì»¤ë°‹:** [ì‘ì—… ì¤‘]
+**ì»¤ë°‹:** `228eef2`
 
 ---
 
@@ -11,14 +11,11 @@
 ### D203-1: Break-even Threshold (SSOT)
 ìˆ˜ìˆ˜ë£Œ + ìŠ¬ë¦¬í”¼ì§€ + ë²„í¼ë¥¼ ë°˜ì˜í•œ ìµœì†Œ ì§„ì… ìŠ¤í”„ë ˆë“œ(bps) ê³µì‹ì„ ì½”ë“œë¡œ SSOTí™”.
 
-### D203-2: Opportunity Detector v1 (ì˜µì…˜ í™•ì¥)
-ë‘ ê±°ë˜ì†Œ ê°€ê²©ì„ ì…ë ¥ë°›ì•„ ì°¨ìµê±°ë˜ ê¸°íšŒë¥¼ íƒì§€í•˜ëŠ” ëª¨ë“ˆ.
+**Note:** D203-2 Opportunity DetectorëŠ” ë³„ë„ ë¦¬í¬íŠ¸ë¡œ ë¶„ë¦¬ë¨ (`D203-2_REPORT.md`)
 
 ---
 
 ## âœ… ì™„ë£Œ í•­ëª©
-
-### 1. D203-1 Break-even Threshold
 **íŒŒì¼:**
 - `arbitrage/v2/domain/break_even.py` (ì‹ ê·œ, 156 lines)
 - `tests/test_d203_1_break_even.py` (ì‹ ê·œ, 278 lines)
@@ -56,41 +53,12 @@ break_even_bps = fee_entry_bps + fee_exit_bps + slippage_bps + buffer_bps
 
 ---
 
-### 2. D203-2 Opportunity Detector v1
-**íŒŒì¼:**
-- `arbitrage/v2/opportunity/detector.py` (ì‹ ê·œ, 154 lines)
-- `tests/test_d203_2_opportunity_detector.py` (ì‹ ê·œ, 258 lines)
-
-**êµ¬í˜„:**
-- `OpportunityCandidate(dataclass)` - ê¸°íšŒ í›„ë³´ (symbol, spread_bps, edge_bps, direction, profitable)
-- `detect_candidates(...)` - ë‹¨ì¼ ì‹¬ë³¼ ê¸°íšŒ íƒì§€
-- `detect_multi_candidates(...)` - ì—¬ëŸ¬ ì‹¬ë³¼ ê¸°íšŒ íƒì§€ + Edge ìˆœ ì •ë ¬
-
-**Direction:**
-- `BUY_A_SELL_B` - Aì—ì„œ ì‚¬ê³  Bì—ì„œ íŒ”ê¸° (A < B)
-- `BUY_B_SELL_A` - Bì—ì„œ ì‚¬ê³  Aì—ì„œ íŒ”ê¸° (B < A)
-- `NONE` - ê¸°íšŒ ì—†ìŒ
-
-**Reuse-First:**
-- âœ… BreakEvenParams ì¬ì‚¬ìš© (D203-1)
-- âœ… SpreadModel ë¡œì§ ì°¸ì¡° (V1: spread_percent ê³µì‹)
-
-**í…ŒìŠ¤íŠ¸:** 6/6 PASS (0.18s)
-1. ë‹¨ì¼ ê¸°íšŒ íƒì§€ (profitable)
-2. ë‹¨ì¼ ê¸°íšŒ íƒì§€ (unprofitable)
-3. Direction íŒë‹¨
-4. ì—¬ëŸ¬ ê¸°íšŒ ì¤‘ profitableë§Œ í•„í„°ë§
-5. Edge ìˆœì„œëŒ€ë¡œ ì •ë ¬
-6. Invalid ê°€ê²© ì²˜ë¦¬
-
----
-
-## ğŸ§ª Gate ê²€ì¦ ê²°ê³¼
+## ğŸ§ª Gate ê²€ì¦ ê²°ê³¼ (D203-1 + D203-2 í†µí•©)
 
 | Gate | ìƒíƒœ | í…ŒìŠ¤íŠ¸ | ì‹œê°„ | ê²°ê³¼ |
 |------|------|--------|------|------|
 | Doctor | âœ… PASS | 2512 collected | < 1s | Import/collect OK |
-| Fast | âœ… PASS | 67/67 | 0.68s | V2 core tests |
+| Fast | âœ… PASS | 67/67 | 0.68s | V2 core tests (D203-1: 9, D203-2: 6 í¬í•¨) |
 | Regression | âœ… PASS | 95/95 | 0.90s | D98 + V2 combined |
 
 **Evidence:** `logs/evidence/d203_1_20251230_0047_5504337/gate_results.md`
@@ -114,12 +82,11 @@ break_even_bps = fee_entry_bps + fee_exit_bps + slippage_bps + buffer_bps
 
 ## ğŸ“ ë³€ê²½ íŒŒì¼ ëª©ë¡
 
-### ì‹ ê·œ íŒŒì¼ (5ê°œ)
+### ì‹ ê·œ íŒŒì¼ (2ê°œ, D203-1 ì „ìš©)
 1. `arbitrage/v2/domain/break_even.py` - Break-even ê³µì‹ (156 lines)
-2. `arbitrage/v2/opportunity/__init__.py` - Package init (4 lines)
-3. `arbitrage/v2/opportunity/detector.py` - Opportunity detector (154 lines)
-4. `tests/test_d203_1_break_even.py` - Break-even í…ŒìŠ¤íŠ¸ (278 lines)
-5. `tests/test_d203_2_opportunity_detector.py` - Detector í…ŒìŠ¤íŠ¸ (258 lines)
+2. `tests/test_d203_1_break_even.py` - Break-even í…ŒìŠ¤íŠ¸ (278 lines)
+
+**Note:** D203-2 ê´€ë ¨ íŒŒì¼(detector.py, test_d203_2)ì€ D203-2_REPORT.md ì°¸ì¡°
 
 ### ìˆ˜ì • íŒŒì¼ (2ê°œ)
 1. `D_ROADMAP.md` - D203-1/D203-2 DONE ìƒíƒœ ì—…ë°ì´íŠ¸
@@ -129,9 +96,10 @@ break_even_bps = fee_entry_bps + fee_exit_bps + slippage_bps + buffer_bps
 
 ## ğŸ” Tech-Debt / ë‚¨ì€ ì¼
 
-**ì—†ìŒ** - D203-1/D203-2ëŠ” ì™„ì „ ì™„ë£Œ.
+**ì—†ìŒ** - D203-1ì€ ì™„ì „ ì™„ë£Œ.
 
 **ë‹¤ìŒ ë‹¨ê³„:**
+- D203-2: Opportunity Detector v1 (ë³„ë„ ë¦¬í¬íŠ¸)
 - D203-3: Engineì— Opportunity Detector ì—°ê²° (ì–‡ì€ ë˜í•‘)
 - D204: Paper Execution (ëª¨ì˜ ì‹¤í–‰)
 
@@ -149,9 +117,8 @@ break_even_bps = fee_entry_bps + fee_exit_bps + slippage_bps + buffer_bps
 
 ## âœ… ê²°ë¡ 
 
-**D203-1 + D203-2: ì™„ì „ ì™„ë£Œ**
+**D203-1: ì™„ì „ ì™„ë£Œ**
 - Break-even ê³µì‹ SSOTí™” âœ…
-- Opportunity Detector v1 êµ¬í˜„ âœ…
 - Gate 3ë‹¨ 100% PASS âœ…
-- Reuse-First ì¤€ìˆ˜ âœ…
+- Reuse-First ì¤€ìˆ˜ (FeeModel, ThresholdConfig) âœ…
 - ì¤‘ë³µ ëª¨ë“ˆ 0ê°œ âœ…
diff --git a/docs/v2/reports/D203/D203-2_REPORT.md b/docs/v2/reports/D203/D203-2_REPORT.md
new file mode 100644
index 0000000..9070fda
--- /dev/null
+++ b/docs/v2/reports/D203/D203-2_REPORT.md
@@ -0,0 +1,154 @@
+# D203-2 Report: Opportunity Detector v1
+
+**ì‘ì„±ì¼:** 2025-12-30  
+**ìƒíƒœ:** âœ… DONE  
+**ì»¤ë°‹:** `228eef2`
+
+---
+
+## ğŸ“‹ ëª©í‘œ ë° ë²”ìœ„
+
+### D203-2: Opportunity Detector v1 (ì˜µì…˜ í™•ì¥)
+ë‘ ê±°ë˜ì†Œ ê°€ê²©ì„ ì…ë ¥ë°›ì•„ ì°¨ìµê±°ë˜ ê¸°íšŒë¥¼ íƒì§€í•˜ëŠ” ëª¨ë“ˆ.
+
+**Note:** 
+- ì›ë˜ D203-2ëŠ” "Replay/Backtest Gate" ê³„íšì´ì—ˆìœ¼ë‚˜, D203-1ì˜ ìì—°ìŠ¤ëŸ¬ìš´ í™•ì¥ìœ¼ë¡œ Opportunity Detectorë¥¼ ë¨¼ì € êµ¬í˜„
+- Backtest GateëŠ” D204-2ë¡œ ì´ë™ ì˜ˆì •
+
+---
+
+## âœ… ì™„ë£Œ í•­ëª©
+
+**íŒŒì¼:**
+- `arbitrage/v2/opportunity/__init__.py` (ì‹ ê·œ, 4 lines)
+- `arbitrage/v2/opportunity/detector.py` (ì‹ ê·œ, 154 lines)
+- `tests/test_d203_2_opportunity_detector.py` (ì‹ ê·œ, 258 lines)
+
+**êµ¬í˜„:**
+- `OpportunityCandidate(dataclass)` - ê¸°íšŒ í›„ë³´
+  - symbol, exchange_a, exchange_b
+  - price_a, price_b
+  - spread_bps, break_even_bps, edge_bps
+  - direction (BUY_A_SELL_B, BUY_B_SELL_A, NONE)
+  - profitable (edge_bps > 0)
+- `detect_candidates(...)` - ë‹¨ì¼ ì‹¬ë³¼ ê¸°íšŒ íƒì§€
+- `detect_multi_candidates(...)` - ì—¬ëŸ¬ ì‹¬ë³¼ ê¸°íšŒ íƒì§€ + Edge ìˆœ ì •ë ¬
+
+**Direction ì •ì˜:**
+```python
+class OpportunityDirection(str, Enum):
+    BUY_A_SELL_B = "buy_a_sell_b"  # Aì—ì„œ ì‚¬ê³  Bì—ì„œ íŒ”ê¸° (A < B)
+    BUY_B_SELL_A = "buy_b_sell_a"  # Bì—ì„œ ì‚¬ê³  Aì—ì„œ íŒ”ê¸° (B < A)
+    NONE = "none"  # ê¸°íšŒ ì—†ìŒ
+```
+
+**Logic:**
+```python
+def detect_candidates(...):
+    """
+    1. Spread ê³„ì‚° (bps)
+    2. Break-even ê³„ì‚° (bps)
+    3. Edge ê³„ì‚° (bps)
+    4. Direction íŒë‹¨
+    5. Profitable ì—¬ë¶€ í™•ì¸
+    """
+```
+
+**Reuse-First:**
+- âœ… BreakEvenParams ì¬ì‚¬ìš© (D203-1)
+- âœ… SpreadModel ë¡œì§ ì°¸ì¡° (V1: `spread_percent = (price_a - price_b) / price_b * 100`)
+
+**í…ŒìŠ¤íŠ¸:** 6/6 PASS (0.18s)
+1. ë‹¨ì¼ ê¸°íšŒ íƒì§€ (profitable) - BTC spread 101 bps, edge 56 bps
+2. ë‹¨ì¼ ê¸°íšŒ íƒì§€ (unprofitable) - ETH spread 30 bps, edge -15 bps
+3. Direction íŒë‹¨ (BUY_A_SELL_B vs BUY_B_SELL_A)
+4. ì—¬ëŸ¬ ê¸°íšŒ ì¤‘ profitableë§Œ í•„í„°ë§ (3ê°œ â†’ 2ê°œ)
+5. Edge ìˆœì„œëŒ€ë¡œ ì •ë ¬ (BTC 56 bps > XRP 15 bps)
+6. Invalid ê°€ê²© ì²˜ë¦¬ (0 ë˜ëŠ” ìŒìˆ˜ â†’ None ë°˜í™˜)
+
+---
+
+## ğŸ§ª Gate ê²€ì¦ ê²°ê³¼ (D203-1 + D203-2 í†µí•©)
+
+| Gate | ìƒíƒœ | í…ŒìŠ¤íŠ¸ | ì‹œê°„ | ê²°ê³¼ |
+|------|------|--------|------|------|
+| Doctor | âœ… PASS | 2512 collected | < 1s | Import/collect OK |
+| Fast | âœ… PASS | 67/67 | 0.68s | V2 core tests (D203-1: 9, D203-2: 6 í¬í•¨) |
+| Regression | âœ… PASS | 95/95 | 0.90s | D98 + V2 combined |
+
+**Evidence:** `logs/evidence/d203_1_20251230_0047_5504337/gate_results.md`
+
+---
+
+## ğŸ“Š Scan-First ê²°ê³¼
+
+**V1 ì°¸ì¡° ëª¨ë“ˆ:**
+| ê¸°ëŠ¥ | V1 ìœ„ì¹˜ | V2 ì ìš© | ì¬ì‚¬ìš© ë°©ì‹ | ê²°ì • |
+|------|---------|---------|-----------|------|
+| Spread ê³„ì‚° ê³µì‹ | `arbitrage/cross_exchange/spread_model.py` | `arbitrage/v2/opportunity/detector.py` | âœ… ë¡œì§ ì°¸ì¡° | REFERENCE |
+| Break-even íŒŒë¼ë¯¸í„° | `arbitrage/v2/domain/break_even.py` | `arbitrage/v2/opportunity/detector.py` | âœ… import ì¬ì‚¬ìš© | KEEP |
+
+**ì¤‘ë³µ ëª¨ë“ˆ:** 0ê°œ âœ…
+
+**Evidence:** `logs/evidence/d203_1_20251230_0047_5504337/scan_reuse_map.md`
+
+---
+
+## ğŸ“ ë³€ê²½ íŒŒì¼ ëª©ë¡
+
+### ì‹ ê·œ íŒŒì¼ (3ê°œ, D203-2 ì „ìš©)
+1. `arbitrage/v2/opportunity/__init__.py` - Package init (4 lines)
+2. `arbitrage/v2/opportunity/detector.py` - Opportunity detector (154 lines)
+3. `tests/test_d203_2_opportunity_detector.py` - Detector í…ŒìŠ¤íŠ¸ (258 lines)
+
+**Note:** D203-1 ê´€ë ¨ íŒŒì¼(break_even.py, test_d203_1)ì€ D203-1_REPORT.md ì°¸ì¡°
+
+---
+
+## ğŸ” Tech-Debt / ë‚¨ì€ ì¼
+
+### âš ï¸ Spread ì •ì˜ ë¹„ëŒ€ì¹­ (SSOT ë¬¸ì„œí™” í•„ìš”)
+**í˜„ì¬ êµ¬í˜„:**
+```python
+spread_percent = (price_a - price_b) / price_b * 100
+spread_bps = abs(spread_percent * 100)
+```
+
+**ì´ìŠˆ:**
+- ë¶„ëª¨ê°€ í•­ìƒ `price_b`ë¼ì„œ A/Bë¥¼ ë°”ê¾¸ë©´ spread í¬ê¸°ê°€ ë¯¸ì„¸í•˜ê²Œ ë‹¬ë¼ì§€ëŠ” ë¹„ëŒ€ì¹­ ì •ì˜
+- v1ë¡œëŠ” "ê·¸ëŸ´ ìˆ˜ ìˆìŒ"ì´ì§€ë§Œ, SSOT ë¬¸ì„œì— **"ì™œ price_b ê¸°ì¤€ì¸ì§€"** ëª…ì‹œ í•„ìš”
+- ëŒ€ì•ˆ: mid-price ê¸°ë°˜ `(price_a + price_b) / 2` ë˜ëŠ” ìµœì†Œê°’ ê¸°ë°˜ `min(price_a, price_b)`
+
+**ì¡°ì¹˜:** D203-3 ë˜ëŠ” D204ì—ì„œ SSOT ë¬¸ì„œí™” (í˜„ì¬ëŠ” v1 ë™ì‘)
+
+### ğŸ”¶ Direction ê¸°ë°˜ Break-even (ë‹¤ìŒ ë‹¨ê³„)
+**í˜„ì¬ ì œí•œ:**
+- Break-evenì´ "ë°©í–¥ì„±"ì„ ë°˜ì˜í•˜ì§€ ì•ŠìŒ
+- í˜„ì‹¤ì€ BUY_A_SELL_Bëƒ BUY_B_SELL_Aëƒì— ë”°ë¼ entry/exit exchangeê°€ ë°”ë€Œê³ , ìˆ˜ìˆ˜ë£Œ/ìŠ¬ë¦¬í”¼ì§€ë„ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆìŒ
+
+**ì¡°ì¹˜:** D203-3ì—ì„œ Direction ê¸°ë°˜ break-even ê³„ì‚°ìœ¼ë¡œ í™•ì¥ ì—¬ë¶€ ê²°ì •
+
+---
+
+## ğŸ“š ì°¸ì¡°
+
+- SSOT: `D_ROADMAP.md` (line 2655-2678)
+- D203-1: `docs/v2/reports/D203/D203-1_REPORT.md`
+- V1 SpreadModel: `arbitrage/cross_exchange/spread_model.py`
+- V2 BreakEvenParams: `arbitrage/v2/domain/break_even.py`
+- Evidence: `logs/evidence/d203_1_20251230_0047_5504337/`
+
+---
+
+## âœ… ê²°ë¡ 
+
+**D203-2: ì™„ì „ ì™„ë£Œ**
+- Opportunity Detector v1 êµ¬í˜„ âœ…
+- Gate 3ë‹¨ 100% PASS âœ…
+- Reuse-First ì¤€ìˆ˜ (BreakEvenParams, SpreadModel ë¡œì§) âœ…
+- ì¤‘ë³µ ëª¨ë“ˆ 0ê°œ âœ…
+
+**ë‹¤ìŒ ë‹¨ê³„:**
+- D203-3: Opportunity â†’ OrderIntent ë³€í™˜ (ì–‡ì€ ì–´ëŒ‘í„°)
+- D204-1: DB ledger ê¸°ë¡ (orders/fills/trades)
+- D204-2: Paper Execution Gate (ì›ë˜ D203-2 ê³„íš)
diff --git a/tests/test_d203_3_opportunity_to_order_intent.py b/tests/test_d203_3_opportunity_to_order_intent.py
new file mode 100644
index 0000000..19ebc97
--- /dev/null
+++ b/tests/test_d203_3_opportunity_to_order_intent.py
@@ -0,0 +1,350 @@
+"""
+D203-3: Opportunity â†’ OrderIntent Bridge í…ŒìŠ¤íŠ¸
+
+í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤:
+1. Direction BUY_A_SELL_B â†’ BUY intent(exchange_a), SELL intent(exchange_b)
+2. Direction BUY_B_SELL_A â†’ BUY intent(exchange_b), SELL intent(exchange_a)
+3. Unprofitable (Edge<=0) â†’ ë¹ˆ ë¦¬ìŠ¤íŠ¸ (intent ìƒì„± ê¸ˆì§€)
+4. Direction NONE â†’ ë¹ˆ ë¦¬ìŠ¤íŠ¸
+5. MARKET order validation
+6. LIMIT order validation
+7. Invalid price â†’ None candidate â†’ ë¹ˆ ë¦¬ìŠ¤íŠ¸
+8. build_and_convert() í¸ì˜ í•¨ìˆ˜
+"""
+
+import pytest
+from arbitrage.v2.opportunity.intent_builder import (
+    build_candidate,
+    candidate_to_order_intents,
+    build_and_convert,
+)
+from arbitrage.v2.core.order_intent import OrderSide, OrderType
+from arbitrage.v2.domain.break_even import BreakEvenParams
+from arbitrage.domain.fee_model import FeeModel, FeeStructure
+
+
+class TestOpportunityToOrderIntent:
+    """Opportunity â†’ OrderIntent ë³€í™˜ í…ŒìŠ¤íŠ¸"""
+    
+    @pytest.fixture
+    def params(self):
+        """Standard BreakEvenParams fixture"""
+        fee_a = FeeStructure("UPBIT", maker_fee_bps=5.0, taker_fee_bps=5.0)
+        fee_b = FeeStructure("BINANCE", maker_fee_bps=10.0, taker_fee_bps=10.0)
+        fee_model = FeeModel(fee_a=fee_a, fee_b=fee_b)
+        
+        return BreakEvenParams(
+            fee_model=fee_model,
+            slippage_bps=10.0,
+            buffer_bps=5.0,
+        )
+    
+    def test_case1_buy_a_sell_b_direction(self, params):
+        """
+        Case 1: Direction BUY_A_SELL_B
+        
+        Scenario:
+            - Upbit (A): 49,000,000 KRW (ì €ë ´)
+            - Binance (B): 50,000,000 KRW (ë¹„ì‹¸)
+            - Direction: BUY_A_SELL_B
+            - Expected: BUY(upbit), SELL(binance)
+        """
+        candidate = build_candidate(
+            symbol="BTC/KRW",
+            exchange_a="upbit",
+            exchange_b="binance",
+            price_a=49_000_000.0,
+            price_b=50_000_000.0,
+            params=params,
+        )
+        
+        assert candidate is not None
+        assert candidate.profitable is True
+        
+        # Convert to OrderIntents
+        intents = candidate_to_order_intents(
+            candidate=candidate,
+            base_qty=0.01,
+            quote_amount=500_000.0,
+        )
+        
+        assert len(intents) == 2
+        
+        # BUY intent (exchange A = upbit)
+        buy_intent = intents[0]
+        assert buy_intent.exchange == "upbit"
+        assert buy_intent.symbol == "BTC/KRW"
+        assert buy_intent.side == OrderSide.BUY
+        assert buy_intent.order_type == OrderType.MARKET
+        assert buy_intent.quote_amount == 500_000.0
+        
+        # SELL intent (exchange B = binance)
+        sell_intent = intents[1]
+        assert sell_intent.exchange == "binance"
+        assert sell_intent.symbol == "BTC/KRW"
+        assert sell_intent.side == OrderSide.SELL
+        assert sell_intent.order_type == OrderType.MARKET
+        assert sell_intent.base_qty == 0.01
+    
+    def test_case2_buy_b_sell_a_direction(self, params):
+        """
+        Case 2: Direction BUY_B_SELL_A
+        
+        Scenario:
+            - Upbit (A): 50,000,000 KRW (ë¹„ì‹¸)
+            - Binance (B): 49,000,000 KRW (ì €ë ´)
+            - Direction: BUY_B_SELL_A
+            - Expected: BUY(binance), SELL(upbit)
+        """
+        candidate = build_candidate(
+            symbol="BTC/KRW",
+            exchange_a="upbit",
+            exchange_b="binance",
+            price_a=50_000_000.0,
+            price_b=49_000_000.0,
+            params=params,
+        )
+        
+        assert candidate is not None
+        assert candidate.profitable is True
+        
+        # Convert to OrderIntents
+        intents = candidate_to_order_intents(
+            candidate=candidate,
+            base_qty=0.01,
+            quote_amount=500_000.0,
+        )
+        
+        assert len(intents) == 2
+        
+        # BUY intent (exchange B = binance)
+        buy_intent = intents[0]
+        assert buy_intent.exchange == "binance"
+        assert buy_intent.symbol == "BTC/KRW"
+        assert buy_intent.side == OrderSide.BUY
+        
+        # SELL intent (exchange A = upbit)
+        sell_intent = intents[1]
+        assert sell_intent.exchange == "upbit"
+        assert sell_intent.symbol == "BTC/KRW"
+        assert sell_intent.side == OrderSide.SELL
+    
+    def test_case3_unprofitable_no_intents(self, params):
+        """
+        Case 3: Unprofitable (Edge<=0) â†’ ë¹ˆ ë¦¬ìŠ¤íŠ¸
+        
+        Policy (SSOT):
+            - unprofitable candidateëŠ” OrderIntent ìƒì„± ê¸ˆì§€
+        
+        Scenario:
+            - Spread: 30 bps
+            - Break-even: 45 bps
+            - Edge: -15 bps (unprofitable)
+            - Expected: ë¹ˆ ë¦¬ìŠ¤íŠ¸ []
+        """
+        candidate = build_candidate(
+            symbol="ETH/KRW",
+            exchange_a="upbit",
+            exchange_b="binance",
+            price_a=3_000_000.0,
+            price_b=3_009_000.0,  # spread ~30 bps
+            params=params,
+        )
+        
+        assert candidate is not None
+        assert candidate.profitable is False
+        assert candidate.edge_bps < 0
+        
+        # Convert to OrderIntents (should be empty)
+        intents = candidate_to_order_intents(
+            candidate=candidate,
+            base_qty=0.1,
+            quote_amount=300_000.0,
+        )
+        
+        assert len(intents) == 0  # âœ… Policy: unprofitable â†’ ë¹ˆ ë¦¬ìŠ¤íŠ¸
+    
+    def test_case4_direction_none_no_intents(self, params):
+        """
+        Case 4: Direction NONE â†’ ë¹ˆ ë¦¬ìŠ¤íŠ¸
+        
+        Scenario:
+            - price_a == price_b (ë™ì¼ ê°€ê²©)
+            - Direction: NONE
+            - Expected: ë¹ˆ ë¦¬ìŠ¤íŠ¸ []
+        """
+        candidate = build_candidate(
+            symbol="XRP/KRW",
+            exchange_a="upbit",
+            exchange_b="binance",
+            price_a=1000.0,
+            price_b=1000.0,  # ë™ì¼ ê°€ê²©
+            params=params,
+        )
+        
+        # Spread = 0, ê¸°íšŒ ì—†ìŒ
+        # Note: spread=0ì´ë©´ edge < 0ì´ë¯€ë¡œ unprofitable
+        if candidate:
+            assert candidate.profitable is False
+        
+        # Convert (should be empty)
+        intents = candidate_to_order_intents(
+            candidate=candidate,
+            base_qty=100.0,
+            quote_amount=100_000.0,
+        ) if candidate else []
+        
+        assert len(intents) == 0  # âœ… Policy: direction NONE or unprofitable â†’ ë¹ˆ ë¦¬ìŠ¤íŠ¸
+    
+    def test_case5_market_order_validation(self, params):
+        """
+        Case 5: MARKET order validation
+        
+        Verify:
+            - BUY MARKET: quote_amount í•„ìˆ˜
+            - SELL MARKET: base_qty í•„ìˆ˜
+        """
+        candidate = build_candidate(
+            symbol="BTC/KRW",
+            exchange_a="upbit",
+            exchange_b="binance",
+            price_a=49_000_000.0,
+            price_b=50_000_000.0,
+            params=params,
+        )
+        
+        intents = candidate_to_order_intents(
+            candidate=candidate,
+            base_qty=0.01,
+            quote_amount=500_000.0,
+            order_type=OrderType.MARKET,
+        )
+        
+        assert len(intents) == 2
+        
+        buy_intent = intents[0]
+        sell_intent = intents[1]
+        
+        # MARKET order ì†ì„± í™•ì¸
+        assert buy_intent.order_type == OrderType.MARKET
+        assert buy_intent.quote_amount == 500_000.0
+        assert buy_intent.base_qty is None
+        
+        assert sell_intent.order_type == OrderType.MARKET
+        assert sell_intent.base_qty == 0.01
+        assert sell_intent.quote_amount is None
+    
+    def test_case6_limit_order_validation(self, params):
+        """
+        Case 6: LIMIT order validation
+        
+        Verify:
+            - LIMIT order: limit_price í•„ìˆ˜
+            - Fallback to market price if limit_price not provided
+        """
+        candidate = build_candidate(
+            symbol="BTC/KRW",
+            exchange_a="upbit",
+            exchange_b="binance",
+            price_a=49_000_000.0,
+            price_b=50_000_000.0,
+            params=params,
+        )
+        
+        intents = candidate_to_order_intents(
+            candidate=candidate,
+            base_qty=0.01,
+            quote_amount=500_000.0,
+            order_type=OrderType.LIMIT,
+            limit_price_a=49_100_000.0,  # Upbit limit price
+            limit_price_b=50_100_000.0,  # Binance limit price
+        )
+        
+        assert len(intents) == 2
+        
+        buy_intent = intents[0]
+        sell_intent = intents[1]
+        
+        # LIMIT order ì†ì„± í™•ì¸
+        assert buy_intent.order_type == OrderType.LIMIT
+        assert buy_intent.limit_price == 49_100_000.0  # Upbit
+        assert buy_intent.quote_amount == 500_000.0
+        
+        assert sell_intent.order_type == OrderType.LIMIT
+        assert sell_intent.limit_price == 50_100_000.0  # Binance
+        assert sell_intent.base_qty == 0.01
+    
+    def test_case7_invalid_price_no_intents(self, params):
+        """
+        Case 7: Invalid price â†’ None candidate â†’ ë¹ˆ ë¦¬ìŠ¤íŠ¸
+        
+        Scenario:
+            - price_a = 0 (invalid)
+            - Expected: None candidate â†’ ë¹ˆ ë¦¬ìŠ¤íŠ¸
+        """
+        candidate = build_candidate(
+            symbol="BTC/KRW",
+            exchange_a="upbit",
+            exchange_b="binance",
+            price_a=0.0,  # Invalid price
+            price_b=50_000_000.0,
+            params=params,
+        )
+        
+        assert candidate is None
+        
+        # Convert (should be empty)
+        intents = candidate_to_order_intents(
+            candidate=candidate,
+            base_qty=0.01,
+            quote_amount=500_000.0,
+        ) if candidate else []
+        
+        assert len(intents) == 0  # âœ… Invalid price â†’ ë¹ˆ ë¦¬ìŠ¤íŠ¸
+    
+    def test_case8_build_and_convert_convenience(self, params):
+        """
+        Case 8: build_and_convert() í¸ì˜ í•¨ìˆ˜
+        
+        Verify:
+            - build_candidate() + candidate_to_order_intents() í†µí•©
+        """
+        intents = build_and_convert(
+            symbol="BTC/KRW",
+            exchange_a="upbit",
+            exchange_b="binance",
+            price_a=49_000_000.0,
+            price_b=50_000_000.0,
+            params=params,
+            base_qty=0.01,
+            quote_amount=500_000.0,
+        )
+        
+        assert len(intents) == 2
+        
+        # BUY intent
+        assert intents[0].exchange == "upbit"
+        assert intents[0].side == OrderSide.BUY
+        
+        # SELL intent
+        assert intents[1].exchange == "binance"
+        assert intents[1].side == OrderSide.SELL
+    
+    def test_case9_build_and_convert_unprofitable(self, params):
+        """
+        Case 9: build_and_convert() with unprofitable candidate
+        
+        Expected: ë¹ˆ ë¦¬ìŠ¤íŠ¸
+        """
+        intents = build_and_convert(
+            symbol="ETH/KRW",
+            exchange_a="upbit",
+            exchange_b="binance",
+            price_a=3_000_000.0,
+            price_b=3_009_000.0,  # unprofitable
+            params=params,
+            base_qty=0.1,
+            quote_amount=300_000.0,
+        )
+        
+        assert len(intents) == 0  # âœ… Unprofitable â†’ ë¹ˆ ë¦¬ìŠ¤íŠ¸
