#!/usr/bin/env python3 # -*- coding: utf-8 -*- """ D17 Paper/Shadow Mode ??Simulated Exchange ===========================================  Upbit/Binance? ?숈씪???명꽣?섏씠?ㅻ? 媛吏??쒕??덉씠??嫄곕옒?? 二쇰Ц 泥닿껐, ?щ━?쇱?, ?섏닔猷? 遺遺?泥닿껐, 痍⑥냼, 吏???쒕??덉씠?? """  import logging from typing import Dict, List, Optional, Tuple from datetime import datetime, timezone import uuid import numpy as np  from arbitrage.types import (     Price, Order, OrderSide, OrderStatus, ExchangeType, Position )  logger = logging.getLogger(__name__)   class OrderBook:     """二쇰Ц??""          def __init__(self, symbol: str, bid: float, ask: float):         self.symbol = symbol         self.bid = bid         self.ask = ask         self.bid_volume = 1000.0  # 湲곕낯 ?좊룞??        self.ask_volume = 1000.0   class SimulatedExchange:     """     ?쒕??덉씠??嫄곕옒??         Paper/Shadow 紐⑤뱶?먯꽌 ?ъ슜.     ?ㅼ젣 嫄곕옒??API ?몄텧 ?놁씠 ?쒕??덉씠?섎맂 二쇰Ц 泥닿껐.     """          def __init__(         self,         exchange_type: ExchangeType = ExchangeType.UPBIT,         initial_balance: Dict[str, float] = None,         slippage_bps: float = 5.0,  # ?щ━?쇱? (湲곕낯 5bp)         fee_bps: float = 2.5,  # ?섏닔猷?(湲곕낯 2.5bp)         latency_ms: float = 100.0  # 吏??(湲곕낯 100ms)     ):         """         Args:             exchange_type: 嫄곕옒?????            initial_balance: 珥덇린 ?붿븸 {asset: amount}             slippage_bps: ?щ━?쇱? (basis points)             fee_bps: ?섏닔猷?(basis points)             latency_ms: ?ㅽ듃?뚰겕 吏??(諛由ъ큹)         """         self.exchange_type = exchange_type         self.slippage_bps = slippage_bps         self.fee_bps = fee_bps         self.latency_ms = latency_ms                  # ?붿븸         self.balance = initial_balance or {"KRW": 10_000_000, "USDT": 1000}                  # 二쇰Ц 湲곕줉         self._orders: Dict[str, Order] = {}         self._order_books: Dict[str, OrderBook] = {}         self._positions: Dict[str, Position] = {}                  # ?듦퀎         self.total_fees = 0.0         self.total_trades = 0          async def connect(self) -> None:         """?곌껐 (no-op)"""         logger.info(f"Simulated {self.exchange_type.value} exchange connected")          async def disconnect(self) -> None:         """?곌껐 ?댁젣 (no-op)"""         logger.info(f"Simulated {self.exchange_type.value} exchange disconnected")          async def get_balance(self) -> Dict[str, float]:         """?붿븸 議고쉶"""         return self.balance.copy()          async def get_ticker(self, symbol: str) -> Optional[Price]:         """?꾩옱 媛寃?議고쉶"""         if symbol not in self._order_books:             return None                  ob = self._order_books[symbol]         return Price(             exchange=self.exchange_type,             symbol=symbol,             bid=ob.bid,             ask=ob.ask,             timestamp=datetime.now(timezone.utc)         )          def set_price(self, symbol: str, bid: float, ask: float) -> None:         """         媛寃??ㅼ젙 (?쒕굹由ъ삤??                  Args:             symbol: ?щ낵             bid: 留ㅼ닔?멸?             ask: 留ㅻ룄?멸?         """         self._order_books[symbol] = OrderBook(symbol, bid, ask)          async def place_order(         self,         symbol: str,         side: OrderSide,         quantity: float,         price: float     ) -> Optional[Order]:         """         二쇰Ц ?앹꽦                  Args:             symbol: ?щ낵             side: 二쇰Ц 諛⑺뼢             quantity: ?섎웾             price: 媛寃?                 Returns:             Order 媛앹껜 ?먮뒗 None         """         order_id = str(uuid.uuid4())[:8]                  # 二쇰Ц ?앹꽦         order = Order(             order_id=order_id,             exchange=self.exchange_type,             symbol=symbol,             side=side,             quantity=quantity,             price=price,             status=OrderStatus.PENDING,             created_at=datetime.now(timezone.utc)         )                  # 利됱떆 泥닿껐 ?쒕??덉씠??        await self._simulate_execution(order)                  self._orders[order_id] = order         self.total_trades += 1                  logger.info(             f"Order placed: {order_id} {side.value} {quantity} @ {price} "             f"(filled: {order.filled_quantity})"         )                  return order          async def cancel_order(self, order_id: str) -> bool:         """二쇰Ц 痍⑥냼"""         if order_id not in self._orders:             return False                  order = self._orders[order_id]                  # 誘몄껜寃?遺遺꾨쭔 痍⑥냼 媛??        if order.status in [OrderStatus.FILLED, OrderStatus.CANCELLED]:             return False                  order.status = OrderStatus.CANCELLED         logger.info(f"Order cancelled: {order_id}")                  return True          async def get_order_status(self, order_id: str) -> Optional[Order]:         """二쇰Ц ?곹깭 議고쉶"""         return self._orders.get(order_id)          async def subscribe_prices(         self,         symbols: List[str],         callback: callable     ) -> None:         """         媛寃?援щ룆 (no-op, ?쒕굹由ъ삤??                  Args:             symbols: ?щ낵 紐⑸줉             callback: 肄쒕갚 (?ъ슜?섏? ?딆쓬)         """         logger.info(f"Subscribed to {len(symbols)} symbols (simulated)")          async def _simulate_execution(self, order: Order) -> None:         """         二쇰Ц 泥닿껐 ?쒕??덉씠??                 Args:             order: 二쇰Ц         """         if order.symbol not in self._order_books:             # 二쇰Ц???놁쑝硫?誘몄껜寃?            order.status = OrderStatus.PENDING             return                  ob = self._order_books[order.symbol]                  # ?щ━?쇱? ?곸슜         slippage_ratio = self.slippage_bps / 10000                  if order.side == OrderSide.BUY:             # 留ㅼ닔: ask 媛寃⑹뿉 ?щ━?쇱? 異붽?             execution_price = ob.ask * (1 + slippage_ratio)                          # ?좊룞???뺤씤             if order.quantity <= ob.ask_volume:                 # ?꾨? 泥닿껐                 order.filled_quantity = order.quantity                 order.status = OrderStatus.FILLED             else:                 # 遺遺?泥닿껐                 order.filled_quantity = ob.ask_volume * 0.8  # 80% 泥닿껐                 order.status = OrderStatus.PARTIALLY_FILLED                  else:  # SELL             # 留ㅻ룄: bid 媛寃⑹뿉 ?щ━?쇱? 李④컧             execution_price = ob.bid * (1 - slippage_ratio)                          # ?좊룞???뺤씤             if order.quantity <= ob.bid_volume:                 # ?꾨? 泥닿껐                 order.filled_quantity = order.quantity                 order.status = OrderStatus.FILLED             else:                 # 遺遺?泥닿껐                 order.filled_quantity = ob.bid_volume * 0.8                 order.status = OrderStatus.PARTIALLY_FILLED                  # ?섏닔猷?怨꾩궛         fee_ratio = self.fee_bps / 10000         fee = order.filled_quantity * execution_price * fee_ratio         self.total_fees += fee                  # ?붿븸 ?낅뜲?댄듃         if order.side == OrderSide.BUY:             cost = order.filled_quantity * execution_price + fee             base_asset = "KRW" if self.exchange_type == ExchangeType.UPBIT else "USDT"             self.balance[base_asset] -= cost                          quote_asset = order.symbol.split("-")[-1] if "-" in order.symbol else order.symbol.replace("USDT", "")             self.balance[quote_asset] = self.balance.get(quote_asset, 0) + order.filled_quantity                  else:  # SELL             revenue = order.filled_quantity * execution_price - fee             base_asset = "KRW" if self.exchange_type == ExchangeType.UPBIT else "USDT"             self.balance[base_asset] += revenue                          quote_asset = order.symbol.split("-")[-1] if "-" in order.symbol else order.symbol.replace("USDT", "")             self.balance[quote_asset] = self.balance.get(quote_asset, 0) - order.filled_quantity                  logger.debug(             f"Execution simulated: {order.order_id} "             f"filled={order.filled_quantity} @ {execution_price:.0f} "             f"fee={fee:.0f}"         )          def get_stats(self) -> Dict:         """?듦퀎 議고쉶"""         return {             "total_trades": self.total_trades,             "total_fees": self.total_fees,             "balance": self.balance.copy(),             "orders_count": len(self._orders),         }